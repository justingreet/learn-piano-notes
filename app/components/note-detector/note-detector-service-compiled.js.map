{"version":3,"sources":["note-detector-service.js"],"names":[],"mappings":"AAAA;;AAEA,IAAI,qBAAqB,QAAQ,MAAR,CAAe,kCAAf,CAArB;;AAEJ,mBAAmB,OAAnB,CAA2B,qBAA3B,EAAkD,CAAC,aAAD,EAChD,UAAS,WAAT,EAAsB;;AAEpB,OAAK,QAAL,GAAgB,EAAhB,CAFoB;AAGpB,OAAK,WAAL;;;;;;;AAHoB,MAUpB,CAAK,gBAAL,GAAwB,EAAxB,CAVoB;;AAYpB,OAAK,oBAAL,GAA4B,CAA5B,CAZoB;;AAepB,MAAI,OAAO,IAAP;;;;;;;;;AAfgB,MAyBpB,CAAK,oBAAL,GAA4B,UAAS,WAAT,EAAsB;;;AAGhD,SAAK,gBAAL,CAAsB,IAAtB,CAA2B,WAA3B,EAHgD;;AAKhD,QAAI,aAAa,CAAC,CAAD,CAL+B;AAMhD,QAAI,YAAY,CAAZ,CAN4C;AAOhD,SAAK,IAAI,IAAI,KAAK,gBAAL,CAAsB,MAAtB,GAA+B,CAA/B,EAAkC,KAAK,CAAL,EAAQ,GAAvD,EAA4D;AAC1D,UAAI,YAAY,KAAK,gBAAL,CAAsB,CAAtB,CAAZ,CADsD;;AAG1D,UAAI,cAAc,UAAd,EAA0B;AAC5B,qBAAa,CAAb,CAD4B;AAE5B,YAAI,aAAa,KAAK,oBAAL,EAA2B;;;AAG1C,eAAK,gBAAL,GAAwB,KAAK,gBAAL,CAAsB,KAAtB,CAA4B,CAA5B,CAAxB,CAH0C;;AAK1C,iBAAO,SAAP,CAL0C;SAA5C;OAFF,MASO;AACL,oBAAY,CAAZ,CADK;OATP;;AAaA,mBAAa,SAAb,CAhB0D;KAA5D;;;;AAPgD,WA4BzC,WAAP,CA5BgD;GAAtB,CAzBR;;AAwDpB,OAAK,aAAL,GAAqB,UAAS,UAAT,EAAqB;AACxC,SAAK,WAAL,GAAmB,UAAnB,CADwC;GAArB,CAxDD;;AA6DpB,OAAK,YAAL,GAAoB,UAAS,MAAT,EAAiB;AACnC,QAAI,CAAC,KAAK,WAAL,EAAkB;AACrB,YAAM,8BAAN,CADqB;KAAvB;;AAIA,QAAI,iBAAiB,CAAjB,CAL+B;AAMnC,QAAI,UAAU,CAAC,CAAD,CANqB;AAOnC,SAAK,IAAI,SAAS,CAAT,EAAY,UAAU,KAAK,QAAL,EAAe,QAA9C,EAAwD;AACtD,UAAI,gBACA,KAAK,8BAAL,CAAoC,MAApC,EAA4C,MAA5C,CADA;;AADkD,UAIlD,iBAAiB,cAAjB,EAAiC;AACnC,yBAAiB,aAAjB,CADmC;AAEnC,kBAAU,MAAV,CAFmC;OAArC;KAJF;;AAUA,WAAO,KAAK,oBAAL,CAA0B,OAA1B,CAAP,CAjBmC;GAAjB;;;;;;;;;;;;AA7DA,MA4FpB,CAAK,8BAAL,GAAsC,UAAS,MAAT,EAAiB,MAAjB,EAAyB;;;;;AAK7D,QAAI,OAAO,YAAY,sBAAZ,CAAmC,MAAnC,CAAP;;;AALyD,QAQzD,mBACA,YAAY,mBAAZ,CAAgC,IAAhC,EAAsC,KAAK,WAAL,CADtC,CARyD;;AAW7D,QAAI,cAAc,CAAd,CAXyD;;AAa7D,SAAK,IAAI,IAAI,gBAAJ,EAAsB,IAAI,OAAO,MAAP,EAAe,GAAlD,EAAuD;AACrD,UAAI,YAAY,OAAO,IAAI,gBAAJ,CAAnB,CADiD;AAErD,UAAI,kBAAkB,OAAO,CAAP,CAAlB,CAFiD;;AAIrD,qBAAe,KAAK,GAAL,CAAS,YAAY,eAAZ,CAAxB,CAJqD;KAAvD;;AAOA,QAAI,oBAAoB,cAAY,OAAO,MAAP,CApByB;AAqB7D,WAAO,IAAI,iBAAJ,CArBsD;GAAzB,CA5FlB;CAAtB,CADF","file":"note-detector-service-compiled.js","sourcesContent":["'use strict';\n\nvar noteDetectorModule = angular.module('pianoPitchDetector.note-detector');\n\nnoteDetectorModule.service('noteDetectorService', ['utilService',\n  function(utilService) {\n\n    this.NUM_KEYS = 88;\n    this.SAMPLE_RATE;\n\n    /**\n     * Keep a queue of the most recent guesses for key numbers. Note that\n     * the entries in this queue might differ from the actual values\n     * returned from detectKeyNum.\n     */\n    this.detectedKeyQueue = [];\n\n    this.NUM_MATCHES_REQUIRED = 3;\n\n\n    var self = this;\n\n\n    /**\n     * Determines what key number should be displayed to the user. It helps\n     * smooth out results to prevent the jumpiness that seems to exist in\n     * all the other pitch detectors.\n     * @param {number} detectedKey\n     * @returns {number}\n     */\n    this.determineKeyToReturn = function(detectedKey) {\n      // We only need to be able to go far enough back to find the last run\n      // of matching keys of length NUM_MATCHES_REQUIRED.\n      self.detectedKeyQueue.push(detectedKey);\n\n      var prevKeyNum = -1;\n      var runLength = 0;\n      for (var i = self.detectedKeyQueue.length - 1; i >= 0; i--) {\n        var curKeyNum = self.detectedKeyQueue[i];\n\n        if (curKeyNum === prevKeyNum) {\n          runLength += 1;\n          if (runLength >= self.NUM_MATCHES_REQUIRED) {\n            // We want the queue to be as short as possible (we can do some\n            // more optimization later if it becomes an issue).\n            self.detectedKeyQueue = self.detectedKeyQueue.slice(i);\n\n            return curKeyNum;\n          }\n        } else {\n          runLength = 1;\n        }\n\n        prevKeyNum = curKeyNum;\n      }\n\n      // We don't have any run of sufficient length, so just return whatever\n      // was passed in.\n      return detectedKey;\n    };\n\n    this.setSampleRate = function(sampleRate) {\n      self.SAMPLE_RATE = sampleRate;\n    };\n\n\n    this.detectKeyNum = function(buffer) {\n      if (!self.SAMPLE_RATE) {\n        throw \"No sample rate has been set.\";\n      }\n\n      var bestLikelihood = 0;\n      var bestKey = -1;\n      for (var keyNum = 1; keyNum <= self.NUM_KEYS; keyNum++) {\n        var curLikelihood =\n            self.calculateLikelihoodOfFrequency(keyNum, buffer);\n        // We do = because we want the highest frequency that matches.\n        if (curLikelihood >= bestLikelihood) {\n          bestLikelihood = curLikelihood;\n          bestKey = keyNum;\n        }\n      }\n\n      return self.determineKeyToReturn(bestKey);\n    };\n\n\n    /**\n     * We need to figure out how many iterations of a note in the buffer\n     * to test on. In a later, more accurate version, we want to segment\n     * the buffer when we have disagreement to say something like: the\n     * first half is key 34, the second half is key 67. Because we want to\n     * be quick, we choose key 67.\n     *\n     * For now I'll just assume the whole buffer contains a single note\n     * and do as many comparisons as I can.\n     */\n    self.calculateLikelihoodOfFrequency = function(keyNum, values) {\n      //TODO: Attempt to be more accurate with octaves. There is an issue\n      // that sometimes, for example, says that the high C that I pressed is\n      // in fact a lower one.\n\n      var freq = utilService.getFrequencyFromKeyNum(keyNum);\n\n      // Unit of (# samples)/ (iteration of note)\n      var samplesPerPeriod =\n          utilService.getSamplesPerPeriod(freq, self.SAMPLE_RATE);\n\n      var differences = 0;\n\n      for (var j = samplesPerPeriod; j < values.length; j++) {\n        var basePoint = values[j - samplesPerPeriod];\n        var comparisonPoint = values[j];\n\n        differences += Math.abs(basePoint - comparisonPoint);\n      }\n\n      var differencePerUnit = differences/values.length;\n      return 1 - differencePerUnit;\n    };\n  }]);\n"]}